# Initial idea for implementing RISC-V Type-1 hypervisor

## Introduction

In order to learn more about modern and advanced system, I intend to write a Type-1 hypervisor in Rust on a RISC -V machine. A great goal is to be able to set up multiple virtual machines and run Linux kernel on the hypervisor and a small target is to run single guest OS on the hypervisor. For propose of obeying the "KISS" principle and simplifying problem, I only consider the case of a single guest OS in this article.

## Why RISC -V?

RISC-V is [classically virtualizable](https://en.wikipedia.org/wiki/Popek_and_Goldberg_virtualization_requirements) which means that a hypervisor can rely on any privileged instruction triggering an illegal instruction fault when executed by the (unprivileged) guest OS. This is in contrast to other ISAs like x86 which have instructions that behave differently in user and kernel mode but never trap. Additionally, RISC-V has only 12 supervisor level control registers and only a handful of privileged instructions making the work to implement trap and emulate much more manageable.

## Start

Before we start implementing a type-1 hypervisor, we need to investigate what type-1 hypervisor implementations are available.

At first, we can use H extension descripted in RISC -V privileged manual to build hypervisor. In this case, hypervisor will run on HS-mode and Guest OS will run on VS-mode. The advantage of using this mode is that we can use specific register which RISC -V support, but unfortunately, H extension is still an experimental feature and few boards implement this feature.

The other method to implement type-1 hypervisor is to use S mode trap and emulate. In this case, hypervisor run on S mode and our Guest OS run on U mode. Although guest OS run U mode but it think it run on S mode, the guest OS will execute system instructions which can only be executed on S mode and M mode. After that, Trap handler function will be triggered and fall into hypervisor. Trap handler will do the same thing as guest OS and return guest OS. But guest OS will never not realize it run on U mode. The advantages of using this method is able to run on any RISC -V machine but we have to maintain more structures.

In this article I will briefly describe how to use the S mode trap and emulate approach to implement a type-1 hypervisor.

## CPU Virtualization

In order to facilitate the description of the process of CPU virtualization, we consider a simple example: Suppose the guest OS will execute a `csrr` instruction and it will fall into trap handler function. Trap handler will store common register on stack, handle interrupt and execption and restore common resister. So the hypervisor must store the state of all CSR registers of the guest OS as hardware do.

 When guest OS want to get value of CSR, the hypervisor firstly fetch and decode current instruction from `sepc` register, and then the saved CSR structure can be retrived from hypervisor and written to the corresponding location on stack so that the guest OS can get CSR value after trap handler function return.

Similarly, when guest OS execute `csrw` commond, the hypervisor will write value to the saved CSR structure. When a interrupt or exception happend on guest OS, the hypervisor will handle instead of guest OS.

## Memory Virtualization

Since the guest OS runs in U mode, it thinks it can monopolize all memory resources. So we have to separate guest memory from host memory otherwise the address space will be cluttered when multiple guest OSs are running at the same time. A technique called `shadow page table` can solve this problem very well. 

Shadow page tables are used by the hypervisor to keep track of the state in which the guest "thinks" its page tables should be. The guest can't be allowed access to the hardware page tables because then it would essentially have control of the machine. So, the hypervisor keeps the "real" mappings (guest virtual -> host physical) in the hardware when the relevant guest is executing, and keeps a representation of the page tables that the guest thinks it's using "in the shadows".

As far as page faults go, nothing changes from the *hardware's* point of view (remember, the hypervisor makes it so the page tables used by the hardware contain GVA->HPA mappings), a page fault will simply generate an exception and redirect to the appropriate exception handler. However, when a page fault occurs while a VM is running, this exception can be "forwarded" to the hypervisor, which can then handle it appropriately.

The hypervisor must build up these shadow page tables as it sees page faults generated by the guest. When the guest writes a mapping into one of its page tables, the hypervisor won't know right away, so the shadow page tables won't instantly "be in sync" with what the guest intends. So the hypervisor will build up the shadow page tables in. A simple example are as followed:

- guest OS try to build address translation from guest virtual address to guest physical address, and it write root page table address to `satp` register.

- `csrw` operation will trigger trap handler and fall into hypervisor.

- hypervisor walk guest OS page table and build shadow page table which map guest virtual address to host physical address and set page table flag to `readonly`.

- hypervisor write shadow page into `satp` register.

- When guest OS try to modify page table will trigger exception and hypervisor execption handler will modify shadow page table.

Hypervior will also check if page fault caused by shadow page table and will turn into guest OS trap handler if no.

## IO Virtualization

Hypervisor can initialize IO device by device tree file supported by guest OS and store address information into context. When guest OS want to use IO device, it will access memory and this will trigger an page fault. hypervisor can judge if guest OS access IO device and simulate as hardware does.

IO device state will be saved as a structure in hypervisor. When an external interrupt happen, hypervisor will stimulate hardware and modify state of IO devices and trigger a guest OS interrupt handler.
